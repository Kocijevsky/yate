// vim: set filetype=javascript:

// ----------------------------------------------------------------------------------------------------------------- //
// module
// ----------------------------------------------------------------------------------------------------------------- //

// На первое время, шаблоны (и соответственно matcher) выводятся только на верхнем уровне.

module
    var yr = yr || require('yate/lib/runtime.js');

    (function() {

        var cmpNN = yr.cmpNN;
        var cmpSN = yr.cmpSN;
        var nodeset2xml = yr.nodeset2xml;
        var nodeset2boolean = yr.nodeset2boolean;
        var nodeset2attrvalue = yr.nodeset2attrvalue;
        var nodeset2scalar = yr.nodeset2scalar;
        var scalar2attrvalue = yr.scalar2attrvalue;
        var xml2attrvalue = yr.xml2attrvalue;
        var scalar2xml = yr.scalar2xml;
        var xml2scalar = yr.xml2scalar;
        var simpleScalar = yr.simpleScalar;
        var simpleBoolean = yr.simpleBoolean;
        var selectNametest = yr.selectNametest;
        var closeAttrs = yr.closeAttrs;

        var M = new yr.Module();

        %{ Block.js__defs() }

        %{ Block.Templates :defs }

        M.matcher = %{ Block.js__matcher() };
        M.imports = %{ Block.imports };

        yr.register('%{ . :name }', M);

    })();

module :name [ ast.Name ]

    %{ Name }

//  Дефольтное название модуля.
module :name

    main

import

    '%{ Name }'

// ----------------------------------------------------------------------------------------------------------------- //
// defs: template, function_, key, var_
// ----------------------------------------------------------------------------------------------------------------- //

// template.

template :defs

    // match %{ Selectors :yate } %{ Mode }
    M.t%{ Id } = %{ . :def };
    %{ . :selectors }

template :def
    function t%{ Id }(m, c%{ cid }, i%{ cid }, l%{ cid }, a%{ rid }%{ Args }) {
        %{ Args :defaults }
        %{ . :template_prologue }

        %{ Body :output }

        return r%{ rid };
    }

template_mode [ ast.Value ]

    : %{ Value }

template :selectors [ ast.Selectors.length() === 1 ]

    M.t%{ Id }.j = %{ Selectors :template_selector };
    M.t%{ Id }.a = %{ Selectors :template_abs };

template :selectors

    M.t%{ Id }.s = [ %{ Selectors :template_selector } ];
    M.t%{ Id }.a = [ %{ Selectors :template_abs } ];

template :template_prologue [ ast.get_type() === 'array' ]

    var r%{ rid } = [];

template :template_prologue [ ast.get_type() === 'object' ]

    var r%{ rid } = {};

template :template_prologue

    var r%{ rid } = '';


// Для jpath выводим имя его переменной, для / -- 1.

jpath :template_selector [ ast.is_root() ]

    1

jpath :template_selector

    j%{ Id }

jpath :template_abs [ ast.Abs ]

    1

jpath :template_abs

    0


// ----------------------------------------------------------------------------------------------------------------- //

function_ :comment

    func %{ Name }(%{ Args :yate }) : %{ get_type() }

function_ :defs [ ast.isImported ]

    // imported %{ . :comment }

// function_

function_ :defs [ ast.is_global() ]

    // %{ . :comment }
    M.f%{ Id } = %{ . :def };

function_ :defs

    %{ . :def }


//  Только функции с типом attr или xml используют параметр aN.
function_ :def [ ast.get_type() === 'attr' || ast.get_type() === 'xml' ]

    function f%{ Id }(m, c%{ cid }, i%{ cid }, l%{ cid }, a%{ rid }%{ Args }) {
        %{ . :function_body }
    }

function_ :def

    function f%{ Id }(m, c%{ cid }, i%{ cid }, l%{ cid }%{ Args }) {
        %{ . :function_body }
    }

//  Тело функции состоит из одного инлайнового выражения (без каких-либо определений).
* :function_body [ ast.Body.is_inline() ]
    %{ Args :defaults }

    return %{ Body };

* :function_body

    %{ Args :defaults }
    %{ . :function_prologue }

    %{ Body :output }

    %{ . :function_epilogue }


* :function_prologue [ ast.get_type() === 'object' ]

    var r%{ rid } = {};

* :function_prologue [ ast.get_type() === 'array' ]

    var r%{ rid } = [];

* :function_prologue [ ast.get_type() === 'nodeset' ]

    var r%{ rid } = [];

* :function_prologue [ ast.get_type() === 'boolean' ]

    var r%{ rid } = false;

//  Функция типа attr не использует переменную rN.
* :function_prologue [ ast.get_type() !== 'attr' ]

    var r%{ rid } = '';


* :function_epilogue [ ast.get_type() === 'attr' ]

    return a%{ rid }.a;

* :function_epilogue

    return r%{ rid };


//  ---------------------------------------------------------------------------------------------------------------  //
//  var_
//  ---------------------------------------------------------------------------------------------------------------  //

var_ :body

    %{ Value :prologue }
    %{ Value :output }
    %{ . :epilogue }

var_ :comment

    var %{ Name } : %{ Value.get_type() }


//  Глобальная переменная.
//  ---------------------------------------------------------------------------------------------------------------  //

var_ :defs [ ast.isImported ]

    //  imported %{ . :comment }

var_ :defs [ ast.is_global() ]

    //  %{ . :comment }
    M.v%{ Id } = %{ . :global };

var_ :global [ ast.Value.is_const() ]

    %{ Value }

var_ :global [ ast.Value.is_inline() ]

    function(m, c0, i0, l0) {
        return %{ Value };
    }

var_ :global

    function(m, c0, i0, l0) {
        %{ . :body }
    }

var_ :epilogue [ ast.is_global() && ast.Value.get_type() === 'attr' ]

    return a%{ Value.rid }.a;

var_ :epilogue [ ast.is_global() ]

    return r%{ Value.rid };


//  Локальная переменная
//  ---------------------------------------------------------------------------------------------------------------  //

var_ :defs [ ast.Value.is_inline() ]

    //  %{ . :comment }
    var v%{ Id } = %{ Value };

var_ :defs

    //  %{ . :comment }
    %{ . :body }

var_ :epilogue [ ast.Value.get_type() === 'attr' ]

    var v%{ Id } = a%{ Value.rid }.a;

var_ :epilogue

    var v%{ Id } = r%{ Value.rid };


// ----------------------------------------------------------------------------------------------------------------- //

key :defs [ ast.isImported ]

    //  imported key %{ Name }()

key :defs

    M.k%{ Id } = {};
    M.k%{ Id }.n = %{ . :nodes };
    //  %{ Use.get_type() }
    M.k%{ Id }.u = %{ . :use };
    //  %{ Body.get_type() }
    M.k%{ Id }.b = %{ . :body };
    %{ . :types }

key :nodes

    function k%{ Id }n(m, c0, i0, l0) {
        return %{ Nodes };
    }

key :use

    function k%{ Id }u(m, c0, i0, l0) {
        return %{ Use };
    }

key :body

    function k%{ Id }b(m, c0, i0, l0, a0) {
        %{ . :function_body }
    }

key :types

    M.k%{ Id }.ut = '%{ Use.get_type() }';
    M.k%{ Id }.bt = '%{ Body.get_type() }';

// ----------------------------------------------------------------------------------------------------------------- //

//  jpath

jpath :defs
    var j%{ Id } = %{ . :def };

jpath :def

    [ %{ Steps } ]

jpath_nametest

    0, '%{ Name }'

jpath_dots

    1, %{ Length }

jpath_predicate [ ast.is_local() ]

    2, p%{ Id }

jpath_predicate [ ast.Expr.get_type() === 'boolean' ]

    4, p%{ Id }

jpath_predicate

    3, %{ Expr }

// ----------------------------------------------------------------------------------------------------------------- //

//  jpath_predicate

jpath_predicate :defs
//  FIXME
//  [ this.is_local() || this.Expr.get_type() === 'nodeset' ]

    function p%{ Id }(m, c%{ cid }, i%{ cid }, l%{ cid }) {
        return %{ Expr };
    }


// ----------------------------------------------------------------------------------------------------------------- //
// block and body
// ----------------------------------------------------------------------------------------------------------------- //

body [ ast.AsList ]

    %{ Block :listitem }

body

    %{ Block }

body :output

    %{ Block :output }


// ----------------------------------------------------------------------------------------------------------------- //

block :output [ ast.AsList ]

    %{ . :listitem }

block

    %{ js__defs() }

    %{ Exprs }

block :output

    %{ js__defs() }

    %{ Exprs :output }

block :listitem

    %{ js__defs() }

    %{ Exprs :listitem }

* :prologue [ ast.get_type() === 'array' ]

    var r%{ rid } = [];
    var a%{ rid } = { a: {} };

* :prologue [ ast.get_type() === 'object' ]

    var r%{ rid } = {};
    var a%{ rid } = { a: {} };

* :prologue [ ast.get_type() === 'nodeset' ]

    var r%{ rid } = [];

* :prologue [ ast.get_type() === 'boolean' ]

    var r%{ rid } = false;

* :prologue

    var r%{ rid } = '';
    var a%{ rid } = { a: {} };


// ----------------------------------------------------------------------------------------------------------------- //
// block expressions
// ----------------------------------------------------------------------------------------------------------------- //

if_ :listitem

    %{ . :output }

if_ :output

    if (%{ Condition }) %{ Then :if_body } %{ Elses }

* :if_body

    {
        %{ . :output }
    }

else_if

    else if (%{ Condition }) %{ Body :if_body }

else_

    else %{ Body :if_body }

// ----------------------------------------------------------------------------------------------------------------- //

for_ :listitem

    %{ . :output }

for_ :output

    var items%{ cid } = %{ Selector };
    for (var i%{ Body.cid } = 0, l%{ Body.cid } = items%{ cid }.length; i%{ Body.cid } < l%{ Body.cid }; i%{ Body.cid }++) {
        var c%{ Body.cid } = items%{ cid }[ i%{ Body.cid } ];
        %{ Body :output }
    }

// ----------------------------------------------------------------------------------------------------------------- //

apply :output

    %{ . :output-prologue }
    r%{ rid } += %{ . :output-value }

apply :listitem

    %{ . :output-prologue }
    r%{ rid }.push(%{ . :output-value });

apply :output-prologue [ ast.Expr.id === 'object' ]

    var r%{ Expr.rid } = {};
    %{ Expr :output }

apply :output-value [ ast.Expr.id === 'object' ]
    m.a(m, yr.object2nodeset(r%{ Expr.rid }), %{ Mode :string }, a%{ rid }%{ Args :comma })

apply :output-prologue [ ast.Expr.id === 'array' ]

    var r%{ Expr.rid } = [];
    %{ Expr :output }

apply :output-value [ ast.Expr.id === 'array' ]
    m.a(m, yr.array2nodeset(r%{ Expr.rid }), %{ Mode :string }, a%{ rid }%{ Args :comma })

apply :output-value [ ast.Expr.get_type() === 'object' ]

    m.a(m, yr.object2nodeset(%{ Expr }), %{ Mode :string }, a%{ rid }%{ Args :comma })

apply :output-value [ ast.Expr.get_type() === 'array' ]

    m.a(m, yr.array2nodeset(%{ Expr }), %{ Mode :string }, a%{ rid }%{ Args :comma })

apply :output-value

    m.a(m, %{ Expr }, %{ Mode :string }, a%{ rid }%{ Args :comma })

template_mode :string

    '%{ Value }'

//  ---------------------------------------------------------------------------------------------------------------  //

cdata :listitem

    r%{ rid }.push(%{ Value });

cdata :output

    r%{ rid } += %{ Value };

// ----------------------------------------------------------------------------------------------------------------- //

xml_attr :open

    '%{ Name }': new yr.scalarAttr(%{ Value })

xml_line :output

    r%{ rid } += %{ . :content };

xml_line :listitem

    r%{ rid }.push(%{ . :content });

xml_line :content

    %{ js__content() }


// ----------------------------------------------------------------------------------------------------------------- //

// FIXME: Закэшировать a0.a в отдельную переменную.
attr :output [ ast.Value.is_inline() && ast.Op === '+=' ]

    var tmp%{ cid } = a%{ rid }.a[ %{ Name } ];
    if (tmp%{ cid }) {
        a%{ rid }.a[ %{ Name } ] = tmp%{ cid }.add%{ AttrType }(%{ Value });
    } else {
        a%{ rid }.a[ %{ Name } ] = new yr.%{ AttrType }Attr(%{ Value });
    }

attr :output [ ast.Value.is_inline() ]
    a%{ rid }.a[ %{ Name } ] = new yr.%{ AttrType }Attr(%{ Value });

attr :output [ ast.Op === '+=' ]

    %{ Value :prologue }
    %{ Value :output }
    var tmp%{ cid } = a%{ rid }.a[ %{ Name } ];
    if (tmp%{ cid }) {
        a%{ rid }.a[ %{ Name } ] = tmp%{ cid }.add%{ AttrType }(r%{ Value.rid });
    } else {
        a%{ rid }.a[ %{ Name } ] = new yr.%{ AttrType }Attr(r%{ Value.rid });
    }

attr :output

    %{ Value :prologue }
    %{ Value :output }
    a%{ rid }.a[ %{ Name } ] = new yr.%{ AttrType }Attr(r%{ Value.rid });

attrs_close :output
    r%{ rid } += closeAttrs(a%{ rid });

attrs_open :output

    a%{ rid }.a = {
        %{ Attrs :open }
    };
    a%{ rid }.s = '%{ Name }';



// ----------------------------------------------------------------------------------------------------------------- //

subexpr :listitem

    %{ Block :prologue }
    %{ Block :output }
    r%{ rid }.push(r%{ Block.rid });

subexpr :output

    %{ Block :output }



// ----------------------------------------------------------------------------------------------------------------- //
// Selectors: jpath
// ----------------------------------------------------------------------------------------------------------------- //

jpath [ ast.is_root() ]

    [ c%{ cid }.doc.root ]

jpath [ ast.is_self() ]

    [ c%{ cid } ]

jpath [ ast.IsSimple && ast.as_type === 'scalar' ]

    simpleScalar('%{ Name }', %{ . :context })

jpath [ ast.IsSimple && ast.as_type === 'boolean' ]

    simpleBoolean('%{ Name }', %{ . :context })

jpath [ ast.IsSimple ]

    selectNametest('%{ Name }', %{ . :context }, [])

jpath

    m.s(j%{ Id }, %{ . :context })

jpath :context [ ast.Abs ]

    c%{ cid }.doc.root

jpath :context

    c%{ cid }

// FIXME: Переименовать jpath_filter в inline_filter.
jpath_filter

    m.n(j%{ JPath.Id }, %{ Expr })


// ----------------------------------------------------------------------------------------------------------------- //

arglist_item
    , v%{ Id }

arglist_item :defaults [ ast.Default ]
    v%{ Id } = (v%{ Id } === undefined) ? %{ Default } : v%{ Id };

arglist_item :defaults [ ast.Typedef === 'nodeset' ]
    v%{ Id } = (v%{ Id } === undefined) ? [] : v%{ Id };


// ----------------------------------------------------------------------------------------------------------------- //
//  value
// ----------------------------------------------------------------------------------------------------------------- //

value

    %{ Value }

value :listitem

    r%{ rid }.push(%{ Value });

value :output [ ( ast.get_type() === 'nodeset' || ast.get_type() === 'boolean' ) && !ast.as_type ]

    r%{ rid } = %{ Value };

value :output [ ast.get_type() === 'attr' && ast.Value.is('inline_var') ]

    yr.copyAttrs( a%{ rid }.a, %{ Value } );

value :output [ ast.get_type() === 'attr' && ast.Value.is('inline_function') && ast.Value.def.is('external') ]

    yr.copyAttrs( a%{ rid }.a, %{ Value } );

//  А тут всегда Value должно быть inline_function.
value :output [ ast.get_type() === 'attr' ]

    %{ Value };

value :output

    r%{ rid } += %{ Value };


//  ---------------------------------------------------------------------------------------------------------------  //
//  object
//  ---------------------------------------------------------------------------------------------------------------  //

array :listitem

    %{ . :prologue }
    %{ . :output }
    r%{ ~.rid }.push(r%{ Block.rid });

array :output

    %{ Block :listitem }

object :listitem

    %{ . :prologue }
    %{ . :output }
    r%{ ~.rid }.push(r%{ Block.rid });

object :output

    %{ Block :output }

pair :output [ ast.Value.is_inline() ]

    r%{ rid }[ %{ Key } ] = %{ Value };

pair :output

    %{ Value :prologue }
    %{ Value :output }
    r%{ rid }[ %{ Key } ] = r%{ Value.rid };

// ----------------------------------------------------------------------------------------------------------------- //
// inline expressions
// ----------------------------------------------------------------------------------------------------------------- //

inline_or
    %{ Left } || %{ Right }

inline_and
    %{ Left } && %{ Right }

inline_not
    !%{ Left }

inline_eq [ ast.Op === '!=' && ( ast.Left.get_type() === 'nodeset' || ast.Right.get_type() === 'nodeset' ) ]

    !(%{ . :cmp })

inline_eq

    %{ . :cmp }

inline_eq :cmp [ ast.Left.get_type() === 'nodeset' && ast.Right.get_type() === 'nodeset' ]

    cmpNN(%{ Left }, %{ Right })

inline_eq :cmp [ ast.Left.get_type() === 'nodeset' ]

    cmpSN(%{ Right }, %{ Left })

inline_eq :cmp [ ast.Right.get_type() === 'nodeset' ]

    cmpSN(%{ Left }, %{ Right })

inline_eq :cmp
    %{ Left } %{ Op } %{ Right }

inline_rel
    %{ Left } %{ Op } %{ Right }

inline_add
    %{ Left } %{ Op } %{ Right }

inline_mul
    %{ Left } %{ Op } %{ Right }

inline_unary
    -%{ Left }

inline_union
    (%{ Left }).concat(%{ Right })

inline_subexpr
    (%{ Expr })



// ----------------------------------------------------------------------------------------------------------------- //

inline_function [ ast.IsExternal ]
    (yr.externals['%{ Name }'])(%{ Args })

//  FIXME: Положить в какой-нибудь флаг инфу о том, что аргументом ключа является нодесет.
inline_function [ ast.IsKey && ast.Args.first().get_type() === 'nodeset' ]
    m.k('k%{ Id }', %{ Args }, c%{ cid }.doc.root, true)

inline_function [ ast.IsKey ]
    m.k('k%{ Id }', %{ Args }, c%{ cid }.doc.root)

inline_function [ ast.IsUser && ast.def.is_global() ]
    m.f('f%{ Id }', c%{ cid }, i%{ cid }, l%{ cid }%{ . :attrs }%{ Args :comma })

inline_function [ ast.IsUser ]
    f%{ Id }(m, c%{ cid }, i%{ cid }, l%{ cid }%{ . :attrs }%{ Args :comma })

//  Этот вызов функции сохраняется в переменную, а не просто используется.
//  Поэтому мы передаем вместо aN новый пустой объект для атрибутов.
inline_function :attrs [ ast.get_type() === 'attr' && ast.InlineVarValue ]

    , { a: {} }

inline_function :attrs [ ast.get_type() === 'attr' || ast.get_type() === 'xml' ]

    , a%{ rid }

//  Все остальное -- это встроенные функции, для них есть индивидуальные шаблоны ниже.
//  js__internal() вызывает соответствующий шаблон.
inline_function
    %{ js__internal() }

callargs :comma [ !ast.empty() ]
    , %{ . }

callarg [ ast.Expr.id === 'object' || ast.Expr.id === 'array' ]
    (function() {
        %{ Expr :prologue }
        %{ Expr :output }

        return r%{ Expr.rid };
    })()

callarg

    %{ Expr }

// ----------------------------------------------------------------------------------------------------------------- //

internal_function_true
    true

internal_function_false
    false

internal_function_name [ ast.Signature === 'nodeset' ]
    yr.nodeName( %{Args} )

internal_function_name
    c%{ cid }.name

internal_function_index
    i%{ cid }

internal_function_count [ ast.Signature === 'nodeset' ]
    ( %{Args} ).length

internal_function_count
    l%{ cid }

internal_function_slice
    yr.slice(%{ Args })

internal_function_html
    %{ Args }

internal_function_exists
    yr.exists(%{ Args })

internal_function_number
    (+(%{ Args }))

internal_function_string [ ast.Signature === 'nodeset' ]
    ('' + yr.nodeset2scalar(%{ Args }))

internal_function_string
    ('' + %{ Args })

internal_function_scalar
    %{ Args }

internal_function_boolean
    %{ Args }

internal_function_log
    (console.log(%{ Args }),'')

internal_function_document
    yr.document(%{ Args })

internal_function_subnode
    yr.subnode(%{ Args }, c%{ cid })

// ----------------------------------------------------------------------------------------------------------------- //

inline_var [ ast.def.is_global() ]

    m.v('v%{ Id }', c%{ cid })

inline_var
    v%{ Id }

//  ---------------------------------------------------------------------------------------------------------------  //

inline_number
    %{ Value }

inline_string
    %{ Value }

string_expr
    ( %{ Expr } )

string_literal
    %{ stringify() }



// ----------------------------------------------------------------------------------------------------------------- //
// cast and quote
// ----------------------------------------------------------------------------------------------------------------- //

cast [ ast.From === 'nodeset' && ast.To === 'data' ]
    yr.nodeset2data(%{ Expr })

cast [ ast.From === 'nodeset' && (ast.To === 'scalar' || ast.To === 'xml' || ast.To === 'attrvalue' || ast.To === 'boolean') ]
    nodeset2%{ To }( %{ Expr } )

cast [ ast.From === 'scalar' && (ast.To === 'xml' || ast.To == 'attrvalue') ]
    scalar2%{ To }( %{ Expr } )

cast [ ast.From === 'xml' && ast.To == 'attrvalue' ]
    xml2attrvalue( %{ Expr } )

cast [ ast.From === 'xml' && ast.To == 'scalar' ]
    xml2scalar( %{ Expr } )

cast [ ast.From === 'object' && ast.To == 'nodeset' ]
    yr.object2nodeset( %{ Expr } )

cast [ ast.From === 'array' && ast.To == 'nodeset' ]
    yr.array2nodeset( %{ Expr } )

// FIXME: Не бывает ли ситуации, когда таки нужно нетривиально приводить scalar к boolean?
cast [ ast.From === 'scalar' && ast.To === 'boolean' ]
    %{ Expr }

cast
    %{ Expr }

quote
    yr.%{ Mode }Quote(%{ Expr })

//  ---------------------------------------------------------------------------------------------------------------  //

sort [ ast.Order === 'desc' ]

    yr.sort(%{ Nodes }, function(c%{ cid }, i%{ cid }, l%{ cid }) { return %{ By }; }, true)

sort

    yr.sort(%{ Nodes }, function(c%{ cid }, i%{ cid }, l%{ cid }) { return %{ By }; })

// ----------------------------------------------------------------------------------------------------------------- //
// misc
// ----------------------------------------------------------------------------------------------------------------- //

* :yate
    %{ yate() }


